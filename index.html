<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8">

	<title>JS, ES6, lodash, ...</title>

	<meta name="description" content="Une formation sur le JS">
	<meta name="author" content="Kleegroup">


	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	var link = document.createElement( 'link' );
	link.rel = 'stylesheet';
	link.type = 'text/css';
	link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
	document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<link href='https://fonts.googleapis.com/css?family=Merriweather:700|Source+Sans+Pro:300,600,300italic,600italic|Source+Code+Pro:400,600' rel='stylesheet' type='text/css'>


	<style>
	.reveal {
	font-size: 30px;
	}
	</style>
</head>

<body>


	<div class="reveal">
		<div class="slides">
			<section  data-background='#ffe599'><h1>Javascript</h1><a href='http://get-focus.github.io/formation-js/#/'>http://kleegroup.github.io/formation-js/#/</a></section>
			<section id="part-1">
				<section>
					<h1>Présentation</h1>
				</section>
				<section>
					<h1>Kesako?</h1>
					<ul>
						<li>Langage créé en 1995 pour réaliser des petits scripts dans des pages Web dans le but de les dynamiser</li>
						<li>Le langage respecte l'ensemble des paradigme orienté objet, et est basé sur un principe de <i>prototype</i></li>
						<li>Langage nativement supporté par tous les navigateurs Web, ce qui le rend extrèmement populaire</li>
						<li>Chaque navigateur à cependant son propre moteur JS</li>
					</ul>
				</section>
				<section>
					<h1>De l'utilisation du JS</h1>
					<ul>
							<li>Utilisation au sens premier du langage: dynamiser une page HTML avec quelques scripts côté client</li>
							<li>Utilisation de Jquery: simplification de fonction complexe (écoute d'vènement, manipulation du DOM ...)</li>
							<li>Attention! <mark>JS !== JQuery</mark></li>
							<li>Avènement des SPA: React, Angular, Backbone, Vue ...</li>
							<li>Multiplication des usages
								<ul>
									<li>Application desktop (Electron)</li>
									<li>Application mobile (Cordova, Phonegap)</li>
									<li>Application mobile "native" (React native)</li>
									<li>Serveur web (NodeJS)</li>
									<li>...</li>
								</ul>
							</li>
						</ul>
				</section>
				<section>
					<h1>Standard ECMAScript (ECMA-262)</h1>
					<p>Il s'agit des normes Javascript écrites au cours des années.</p>
					<table>
						<tr><td>ES5 (2009)</td><td>version la plus connu, supportée par tous les navigateurs</td> </tr>
						<tr><td>ES 2016</td><td>Ajoute énormément de modification au langage</td> </tr>
						<tr><td>ES 2017</td><td>version actuelle de la norme très semblable à 2016</td> </tr>
						<tr><td>ES next</td><td>version destinée à devenir la nouvelle norme</td> </tr>
					</table>

					<blockquote>On voit beaucoup de « ES7 » ou « ES8 » qui traînent : en général ça fait référence à l’« ES next » du moment.</blockquote>
				</section>
				<section>
					<h1>Transpilage</h1>
					<p>Le langage évoluant rapidement (tous les ans depuis 2015), les moteurs JS ne suivent pas toujours. Une étape de transpilage nous permet d'écrire notre code
						avec toutes les avancées du langages, et rend cela compréhensible pour les différents moteurs JS</p>
						<ul>
							<li>Babel: Implémente les normes ES2017 et ESnext, les publie sous forme de module pour le développeur.</li>
							<li>TypeScript: Implemente tout ou parti des normes ES2017 et ESnext. Ajoute un sucre syntaxique de typage pour le langage, ainsi qu'un jeu de fonctions avancées propre à ce typage.</li>
						</ul>
				</section>
			</section>

			<section id="part-2">
				<section >
					<h1>Les bases</h1>
				</section>
				<section>
					<h1>Types primitifs</h1>
					<p>Il y a 6 <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Structures_de_donn%C3%A9es#Le_type_ind.C3.A9fini">types primitifs</a> en Javascript:</p>


					<ul>
						<li><b>boolean</b>: résultat d'une assertion logique <i>true</i> ou <i>false</i></li>
						<li><b>null</b>: ne possède qu'une unique valeur <i>null</i></li>
						<li><b>undefined</b>: représente la non-affectation d'une variable</li>
						<li><b>number</b>: contient l'ensemble des valeur numéraire (entier, float, NaN, +Infinity, - Infinity)</li>
						<li><b>string</b>: représente une chaine de caractère à partir d'un ensemble d'élements 16bits non-signés</li>
						<li><b>symbol</b>: type de données unique et inchangeable (souvent utilisé pour créer des identifiants)</li>
					</ul>
					<p>Tout le reste est "Objet" (oui oui même les tableaux...)</p>
					<p>Un objet avec une "call signature" est une fonction</p>
				</section>
				<section>
						<h1>Objets</h1>
						<p>JavaScript est conçu autour d'un paradigme simple, basé sur les <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Utiliser_les_objets">objets</a>.</p>
						<p>Un objet est un ensemble de propriétés et une propriété est une association entre un nom (aussi appelé clé) et une valeur.</p>
						<p>La valeur d'une propriété peut être une fonction, auquel cas la propriété peut être appelée « méthode ».</p>
				</section>
				<section>
					<h1>Objets</h1>
					<pre>
							<code class='javascript'>
/// Création d'un objet
const obj = { first: 'David', last: 'Lopez', age: 77 };
/// Utilisation des propriétés
obj.first  // => 'David'
obj['age'] // => 77
/// Affectation d'une valeur à une propriété
obj.first = 'pierr';
obj.first // => 'pierr'
/// Attention si votre clé de propriété est un nombre!
obj[77] = 'roberto';
obj[77]   // => 'roberto'
obj['77'] // => 'roberto'
obj.77    // => SyntaxError
/// Parce que je fais ce que je veux depuis ES2016 :p
obj['a'+ 12] = 'Gino';
obj.a12; // => 'Gino' évidemment ;)
							</code>
						</pre>
				</section>
				<section>
					<h1>Strings</h1>
					<p>Le type <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Formatage_du_texte">String</a> de JavaScript est utilisé pour représenter des données textuelles.</p>
					<p>C'est un ensemble d'"éléments" de valeurs non signées sur 16 bits (unités de codage UTF-16).</p>
					<p>Chaque élément dans la chaîne de caractères occupe une position dans la chaîne de caractères. Le premier élément se trouve à l'indice 0, le suivant à l'indice 1 et ainsi de suite.</p>
					<p>La longueur d'une chaîne de caractères est le nombre d'éléments qu'elle contient.</p>
					<p>Une String est <b>immuable</b> il est impossible de la modifier une fois créée. Il est cependant possible de recréer une string à partir d'une autre string.</p>
				</section>
				<section>
						<h1>Strings</h1>
						<pre>
								<code class='javascript'>
var maString = 'Hello World!';
maString.length // => 12
maString[0] // => 'H'
maString[0] = 'X'; // Aucun effet. une string est immuable
maString[0] // => 'H'
/// Quelques fonctions
'déjà' < 'demain' // => false Cette comparaison ne fait pas du tout ce que vous pensez!
'déjà'.localeCompare('demain') // => -1 'déjà' est alphabétiquement avant 'demain'
'déjà !'.toLocaleUpperCase()      // => 'DÉJÀ !' Renvoie une nouvelle instance en majuscule
'ÇA POUTRE'.toLocaleLowerCase()   // => 'ça poutre' Renvoie une nouvelle instance en minuscule
'one,two,three'.split(',')        // => ['one', 'two', 'three'] trnsformation en tableau selon un séparateur
'one,,two,three'.split(/\W+/)     // => ['one', 'two'] transformation en tableau selon une expression régulière
'hello'.substring(1)      // => 'ello' renvoie une nouvelle instance d'une partie de la chaine
'hello'.slice(1, -2)      // => 'el' -> [1;length-2[
								</code>
							</pre>
				</section>
				<section>
					<h1>Les tableaux</h1>
					<p>Un <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Collections_index%C3%A9es">Array</a> est un ensemble ordonné de valeurs auxquelles on peut faire référence avec un nom et un indice.</p>
					<p>JavaScript ne possède pas de type particulier pour représenter un tableau. En revanche, il est possible d'utiliser l'objet natif <i>Array</i> ainsi que ses méthodes pour manipuler des tableaux</p>
				</section>
				<section>
						<h1>Les tableaux</h1>
						<pre>
						<code class='javascript'>
let names = ['John', 'David', 'Rodrigo'];

names.length
// => 3

names[0]
// => 'John'

names[12] = 'Pierre';
names.length
// => 13

names[9]
// => undefined (comme 10 et 11): c'est appelé "sparse array"
								</code>
							</pre>
				</section>
				<section>
					<h1>Les tableaux</h1>
					<pre>
						<code class='javascript'>
let data = [1, 2, 3];

// arr1.concat(arg…) -> arr2 [déroule sur 1 niveau, ni "shallow" ni "deep"]
data.concat(4, 5, 6)     // => [1, 2, 3, 4, 5, 6]
data.concat([4, 5, 6])   // => [1, 2, 3, 4, 5, 6]
data.concat(4, [5, 6])   // => [1, 2, 3, 4, 5, 6]
data.concat([4, [5, 6]]) // => [1, 2, 3, 4, [5, 6]] -- 2 niveaux !
data                     // => [1, 2, 3] -- intact !

// arr.join([sep = ',']) -> String
data.join()   // => '1,2,3'
data.join('') // => '123' -- Fréquent en construisant du HTML

// arr1.slice(signedBegin[, signedEnd = length]) -> arr2 -- négatif ok partout !
data.slice(1)      // => [2, 3]
data.slice(1, 1)   // => []
data.slice(1, 2)   // => [2]
data.slice(1, -1)  // => [2]
data.slice(-2)     // => [2, 3]
data.slice(-2, 2)  // => [2]
data.slice(-2, -1) // => [2]
						</code>
					</pre>
				</section>
				<section>
					<h1>Dates</h1>
					<p>JavaScript ne possède pas de type primitif pour représenter des dates. Cependant l'objet Date et ses méthodes permettent de manipuler des dates et des heures au sein d'une application.</p>
					<p>L'objet <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Nombres_et_dates#L'objet_Date">Date</a> possède de nombreuses méthodes pour définir, modifier, obtenir des dates. Il ne possède pas de propriétés</p>
					<p>JavaScript gère les dates de façon similaire à Java. (Donc assez mal...)</p>
					<p>Les dates sont représentées selon les nombres de millisecondes écoulées depuis le premier janvier 1970 à 00h00:00.
							L'objet Date permet de représenter des dates allant de -100 000 000 jours jusqu'à +100 000 000 jours par rapport au premier janvier 1970 UTC.</p>
				</section>
				<section>
						<h1>Dates</h1>
						<pre>
								<code class='javascript'>
new Date()                  //  maintenant !
new Date(y,m,d[,h,m,s,ms]) // Valeur découpée. (un peu lourd...)

date.getYear() // JAMAIS #Bug de l'an 2000 exemple: L'année 1976 renverra 76. Mais l'année 2016 renverra 116. -_-'
date.getFullYear()	// Mieux mais pas vraiment logique dans le nom...
date.getMonth()     // NAZE Java-like qui démarre à… zéro (janvier). #ugly
date.getDay()       // PERDUUUU ! C'est le DOW (Day Of Week), 0 = dim., 6 = sam
date.getDate()      // Le jour du mois.  Super logique.
date.getHours()
date.getMinutes()
date.getSeconds()
date.getMilliseconds() // "Milliseconds", un seul mot : une seule initiale.

// Heure locale du navigateur/système.  On a les mêmes en getUTCXxx()…
								</code>
							</pre>
							<blockquote>Vous avez le choix dans l'implémentation de la date...<br/> De manière générale on préferera utiliser des library de dates type <i>moment.js</i> pour gérer des dates.</blockquote>
					</section>
				<section>
					<h1>Operateurs</h1>
					<table>
							<tr>
								<td>==</td>
								<td>true si les opérandes sont égaux après conversion en valeurs de mêmes types</td>
							</tr>
							<tr>
								<td>!=</td>
								<td>true si les opérandes sont différents.</td>
							</tr>
							<tr>
								<td>===</td>
								<td>true si les opérandes sont égaux et de même type. </td>
							</tr>
							<tr>
								<td>!==</td>
								<td>true si les opérandes ne sont pas égaux ou pas de même type.</td>
							</tr>
							<tr>
								<td>></td>
								<td>true si l'opérande gauche est supérieur (strictement) à l'opérande droit.</td>
							</tr>
							<tr>
								<td>>=</td>
								<td>true si l'opérande gauche est supérieur ou égal à l'opérande droit.</td>
							</tr>
							<tr>
								<td><</td>
								<td>true si l'opérande gauche est inférieur (strictement) à l'opérande droit.</td>
							</tr>
							<tr>
								<td><=</td>
								<td>true si l'opérande gauche est inférieur ou égal à l'opérande droit.</td>
							</tr>
					</table>
				</section>
				<section>
						<h2>Quelques pièges de comparaisons en JS ...</h2>
						<pre>
							<code class='javascript'>
	== ou === ?!

	42 == '42'        // => true  --
	null == undefined // => true  --
	null == 0         // => false --
	0 == undefined    // => false --
	0 == false        // => true  --
	1 == true         // => true  --
	42 == true        // => false --
	'0' == false      // => true  --
	'' == false       // => true  --
	NaN == NaN        // => false --
							</code>
						</pre>
						<blockquote>C'est franchement sale...</blockquote>
					</section>
					<section>
						<h2>Pour éviter les écueils, utiliser ===</h2>
						<pre>
							<code class='javascript'>
	// avec ===, fini de jouer : vérif valeur ET TYPE !

	42 === '42'        // => false
	null === undefined // => false
	null === 0         // => false
	0 === undefined    // => false
	0 === false        // => false
	'0' === false      // => false
	NaN === NaN        // => false -- rien à faire !
							</code>
						</pre>
						<blockquote>Toujours utiliser la comparaison stricte === et !==</blockquote>
				</section>
				<section>
					<h1>Opérateurs</h1>
					<p>Les opérateurs javascripts font des conversions implicites.</p>
					<p>Le javascript ne plantera jamais sur une opération. En revanche il peut vous renvoyer une valeur native comme <i>Nan</i>, <i>+Infinity</i> etc.</p>
					<pre><code class='javascript'>
	!42  => false
	!!42  => true //pratique pour convertir n'importe quelle valeur en booleen
	+'2'  => 2
	"lala" + 42 => "lala42"
	1/0 => Infinity
	"lala" - 42 => NaN

	{} + [] => 0 // Hum ok...
	[] + {} => "[object Object]" // parce que why not!
	{} + {} => "[object Object][object Object]" // Bon ça je veux bien
	[] + [] => "" // Nan mais les gars...
	[] - {} => NaN // -_-'
	+[] => 0 // Ah ah
	+[] + [] => "0" // Vous l'avez?
	+[] + +[] => 0 // Bon ok j'arrete :=)
					</code></pre>
				</section>
				<section>
					<h1>Opérateurs logiques</h1>
					<p>Ces opérateurs servent à resoudre des expressions logique en prenant en compte le caractère <i>"Truthy"</i> ou <i>"Falsy"</i> des valeurs de l'expression</p>
					<table>
						<tr>
							<td>&&</td>
							<td>ET logique. Vrai si les deux expressions ont des valeur <i>Truthy</i>. S'arrête à la première valeur <i>Falsy</i></td>
						</tr>
						<tr>
							<td>||</td>
							<td>OU logique. Vrai si une des deux expressions a une valeur <i>Truthy</i>. S'arrête à la première valeur <i>Truthy</i></td>
						</tr>
						<tr>
								<td>!</td>
								<td>NON logique. Vrai si une l'expression a une valeur <i>Truthy</i>. Faux sinon.</td>
							</tr>
					</table>
					<blockquote>Attention les opérateurs logiques <i>&&</i>, <i>||</i> et <i>!</i> fonctionnent différemment des opérateurs binaire <i>&</i>, <i>|</i> et <i>~</i>. <br/>Pour plus d'info: <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Expressions_et_Op%C3%A9rateurs#Op%C3%A9rateurs_binaires">La doc MDN</a></a></blockquote>
				</section>
				<section>
					<h1>Truthy / Falsy</h1>
					<pre><code class="javascript">
"true" == true => false // la chaine de caratère "true" même après conversion n'est pas égale à true.
"true" && true => true // la chaine de caratère "true" pour ce qui est des expression logique!!
"true"&true => 0 // le & binaire renvoie le bit 0...
"1" == true => true // bah oui après converstion "1" => 1 => true donc égale à true...
					</code></pre>
					<blockquote>Globalement les valeurs suivantes sont Falsy: <i>false, undefined, null, "", 0, NaN</i>. Le reste est Truthy.</blockquote>
				</section>
				<section>
					<h1>Destructuring  / Spreading</h1>
					<p>Des opérateurs de décomposition (<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Syntaxe_d%C3%A9composition">Spread</a>) et d'affectation par décomposition (<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Affecter_par_d%C3%A9composition">Destructuring</a>) ont fait leur apparition pour manipuler plus simplement les objets et les collections.</p>
					<ul>
						<li>La syntaxe de décomposition permet d'étendre un itérable en lieu et place de plusieurs arguments (pour les appels de fonctions) ou de plusieurs éléments (pour les tableaux) ou de paires clés-valeurs (pour les objets).</li>
						<li>L'affectation par décomposition est une expression JavaScript qui permet d'extraire des données d'un tableau ou d'un objet grâce à une syntaxe dont la forme ressemble à la structure du tableau ou de l'objet.</li>
					</ul>
				</section>
				<section>
					<h1>
							Destructuring / Spreading
					</h1>
					<pre>
							<code class="javascript">
/* Arrays */
// Initialisation d'un array
const array = [1, 2, 3];
// On crée un nouvel array à partir de l'ancien
const array2 = [...array, 4, 5]; // array2 => [1,2,3,4,5]
function f(a, b, c) {
		return a + b + c;
}
// On appelle la fonction à partir de l'array
f(...array); // => 1+2+3
// On récupère des éléments précis d'un array.
const [a, b, c, ...rest] = array2; // a=1; b=2, c=3, rest=[4,5]
							</code>
							</pre>
				</section>
				<section>
						<h1>
								Destructuring / Spreading
						</h1>
						<pre>
								<code class="javascript">
/* Objets */
// Initialisation d'un objet.
const objet = {a: 1, b: 2};
// On crée un nouvel objet à partir de l'ancien
const objet2 = {...objet, c: 3}; // objet2 = {a:1, b:2, c:3}
// On récupère des éléments précis d'un objet.
const {a, b, ...rest} = objet2; // a=1 b=2 rest={c:3}
// On peut aussi déstructurer directement dans une fonction :
function g({a, b, c: c2}) {
		return a + b + c2;
}
g(objet2);
								</code>
							</pre>
					</section>
				<section>
					<h1>Interpolation de strings</h1>
					<p>Les nouvelles normes ECMAScript ont permis de faire évoluer le langages et de fournir un moyen de manipuler les strings. Il est désormais possible de créer des chaine de caractères multiligne et paramétrables!</p>
					<pre>
							<code class="javascript">

const person = {nom: Ingargiola, prenom: Thibault};

const stringAvant = 'Bonjour je suis ' + person.prenom + ' ' + person.nom;
const stringApres= `Bonjour je suis ${objet.prenom} ${objet.nom}.
Et le javascript c'était pas mieux avant!`;
							</code>
						</pre>
				</section>
			</section>

			<section id="part3">
				<section>
					<h1>Les fonctions</h1>
					<p>Les fonctions sont un peu la base de toute programmation... Le Javascript n'échappe pas à la règle.</p>
					<p>En JavaScript, les fonctions sont des objets de première classe. Cela signifie qu'elles peuvent être manipulées et échangées, qu'elles peuvent avoir des propriétés et des méthodes, comme tous les autres objets JavaScript. Les fonctions sont des objets <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions">Function</a></p>
					<p>Afin de renvoyer une valeur, la fonction doit comporter une instruction return. Une fonction qui ne renvoie pas de valeur retourne undefined.</p>
				</section>
				<section>
					<h1>Déclaration</h1>
					<pre>
						<code class="javascript">
/// Fonction standard
function a() {
	/// this = contexte appelant
}
/// Variable fonction anonyme (ne pas utiliser)
const b = function() {
	/// this = contexte appelant
}
/// Variable fonction nommée (usage assez rare)
const c = function c() {
	/// this = contexte appelant
}
/// Lambda / "fat arrow" (anonyme)
const d = () => {
	/// this = contexte de la déclaration
}
/// fonction auto-appelante (usage particulier)
(function(){
	/// this = contexte appelant
})()
						</code>
					</pre>
				</section>
				<section>
						<h1>Déclaration</h1>
						<pre>
							<code class="javascript">
/// La syntaxe de a est un raccourci pour celle de b. (usage assez rare)
const e {
    a() {
        /// this = contexte appelant
    },
    b: function b() {
        /// this = contexte appelant
    }
}
/// Dans une classe
class G {
    a() {
        /// this = contexte appelant
		}
		/// Variable d'instance
    b = () => {
        /// this = instance de la classe
    }
}
							</code>
						</pre>
					</section>
				<section>
					<h1>Variables</h1>
				</section>
				<section>
						<h1>Boucles</h1>
				</section>
				<section>
					<h1>Scope</h1>
				</section>
				<section>
					<h1>Closure</h1>
					<p>Il est possible d'imbriquer une fonction au sein d'une fonction. La fonction imbriquée (interne) est privée par rapport à la fonction (externe) qui la contient. Cela forme ce qu'on appelle une <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions#Fonctions_imbriqu%C3%A9es_et_fermetures">Closure</a>.</p>
					<p>Étant donné qu'une fonction imbriquée est une closure, cela signifie que la fonction imbriquée peut « hériter » du scope de la fonction parente. Et donc avoir accès aux variables de cette fonction.</p>
				</section>
				<section>
						<h1>Closure</h1>
						<pre><code class="javascript">
function externe(x) {
	function interne(y) {
			return x + y;
	}
	return interne;
}
var fn_interne = externe(3); // fn_interne est donc une fonction qui prend en parametre y en renvoie 3 + y
var resultat = fn_interne(5); // donc 8

var resultat1 = externe(3)(5); // renvoie 8
						</code></pre>
				</section>
				<section>
					<h1>Closure</h1>
					<pre>
							<code class='javascript'>
function publicFx() {
	let dateAppel = Date.now();
	return function() { console.log(dateAppel); };
}
let privilegedFx1 = publicFx();
// Attendre un bref instant
let privilegedFx2 = publicFx();

// privilegedFx(1,2) sont en fait les fonctions internes construites au
// sein de publicFx, qui grâce aux règles de portée "voient"
// dateAppel.  Elles sont *closed over* par publicFx, ce qui fait
// que les valeurs de dateAppel au moment où les fonctions ont été
// renvoyéees sont préservées
privilegedFx1(); // => affiche la dateAppel du moment de la création de la fonction privilegedFx1!
privilegedFx2(); // => affiche la dateAppel d'après !
							</code>
						</pre>
						<blockquote>Les closures sont un bon moyen de rendre privée une partie du code. Elles seront très utiles pour créer des modules. Mais on y reviendra plus tard...</blockquote>
				</section>
				<section id="part-3-7">
					<h1>Binding</h1>
				</section>
			</section>

			<section id="part-4">
				<section id="part-4-1">
					<h1>Prototypes et classes</h1>
				</section>
				<section id="part-4-2">
					<h1>Prototype</h1>
				</section>
				<section id="part-4-3">
					<h1>Constructeur</h1>
				</section>
				<section id="part-4-4">
					<h1>Classe</h1>
				</section>
				<section id="part-4-5">
					<h1>Chaine d'appel</h1>
				</section>
			</section>

			<section id="part-5">
				<section id="part-5-1">
					<h1>Structure d'une application</h1>
				</section>
				<section id="part-5-2">
					<h1>Déclarer un module</h1>
				</section>
				<section id="part-5-3">
					<h1>Utiliser un module</h1>
				</section>
			</section>

			<section id="part-6">
				<section id="part-6-1">
					<h1>Gestion de l'asynchrone</h1>
				</section>
				<section id="part-6-2">
					<h1>Callbacks</h1>
				</section>
				<section id="part-6-3">
					<h1>Promesses</h1>
				</section>
				<section id="part-6-4">
					<h1>Async/await</h1>
				</section>
			</section>

			<section id="part-7">
				<section id="part-7-1">
					<h1>L'éco-système JS</h1>
				</section>
				<section id="part-7-2">
					<h1>lodash</h1>
				</section>
				<section id="part-7-3">
					<h1>moment</h1>
				</section>
				<section id="part-7-4">
					<h1>i18n</h1>
				</section>
				<section id="part-7-5">
					<h1>node.js</h1>
				</section>
				<section id="part-7-6">
					<h1>babel</h1>
				</section>
				<section id="part-7-7">
					<h1>webpack</h1>
				</section>
				<section id="part-7-8">
					<h1>npm</h1>
				</section>
			</section>

			<section>
				<section data-background='https://media.giphy.com/media/vKZKZ0I9nCAGA/giphy.gif'><h1>Les types de base</h1></section>
				<section data-markdown>
## Les variables

- `const`  Variable constante qui ne peut plus être modifiée
- `var`  portée globale ou locale a une fonction
- `let` portée du block courant `{}`

> A retenir on utilise `const` au maximum et `let` dans les autres cas

				</section>
				<section>

						<h2>Les tableaux</h2>
				</section>
				<section>
					<pre>
						<h2>Les tableaux en ES6</h2>
						<code class='javascript'>

let arr1 = ['one', 'two'], arr2 = ['three', 'four'];
arr1.push(...arr2) // => 4
arr1                // => ['one', 'two', 'three', 'four']
//le map
arr1.map(element => console.log(element))
// for…in itère sur LES PROPRIÉTÉS ÉNUMÉRABLES de N’IMPORTE QUEL OBJET
var arr = ['hello', 'world', , 'cool'];
for (var k in arr){ console.log(k)}; // => 0, 1, 3
// for…of itère sur les éléments d'un objet itérable
for (var k of arr){ console.log(k)}; // => hello, world, undefined, cool

						</code>
					</pre>
				</section>
				<section>
					<pre>
						<h2>"Déguiser" un objet en tableau<h2>
						<code class='javascript'>
// Toi aussi, déguise-toi en tableau !

var fakeArray = { 0: '!', 1: 'ça torche', 2: 'JavaScript', length: 3 };

fakeArray.join = [].join; fakeArray.reverse = [].reverse;
fakeArray.reverse().join(' ');
// => 'JavaScript ça torche !'

// Ou alors :
fakeArray.__proto__ = Array.prototype;
fakeArray.reverse().join(' ');
// => 'JavaScript ça torche !'

// Méthodes « génériques » utilisables: hn
// concat, join, pop, push, reverse, shift,
// slice, sort, splice, toString, unshift.
						</code>
					</pre>
				</section>
				<section>
					<h2>Les boucles</h2>
					<pre>
						<code class='javascript'>
const ARRAY = [1,2,3,4];
for(let i = 0, _l=ARRAY.length; i < _l; i++ ){console.log(ARRAY[i])}

ARRAY.forEach(function(element, idx){console.log(element, idx)});

ARRAY.map(function(element, idx){console.log(element, idx)});
						</code>
					</pre>
				</section>

				<section>
					<h2>Les fonctions</h2>
					<pre>
						<code class='javascript'>
function maFonction() {
	return 'test';
}
maFonction() // test;
const a = () => 'test';
a(); //test
						</code>
					</pre>
				</section>
				<section>
					<h2>in et delete</h2>
					<pre>
						<code class='javascript'>

let person = { name: 'Joe', langs: ['fr', 'en'] };

'name' in person        // => true
person.age = 35;
'age' in person         // => true
person.age = null;
'age' in person         // => true
delete person.age
'age' in person         // => false
person.age              // => undefined

0 in person.langs       // => true
'0' in person.langs     // => true
person.langs[3] = 'de';
2 in person.langs       // => false
3 in person.langs       // => true
delete person.langs[3]
person.langs            // => ['fr', 'en', undefined, undefined]
						</code>
					</pre>
				</section>
				<section>
					<h2>Falsy / Truthy</h2>
				</section>
				<section>
					<h2>XML</h2>
					<pre>
					<code class='xml'>
<menu id="file" value="File">
  <popup>
    <menuitem value="New" onclick="CreateNewDoc()"></menuitem>
    <menuitem value="Open" onclick="OpenDoc()" ></menuitem>
    <menuitem value="Close" onclick="CloseDoc()" ></menuitem>
  </popup>
</menu>
					</code>
				</pre>

				</section>
				<section>
					<h2>JSON</h2>
					<pre>
					<code class='javascript'>
{
    "menu": {
        "id": "file",
        "value": "File",
        "popup": {
            "menuitem": [
                { "value": "New", "onclick": "CreateNewDoc()" },
                { "value": "Open", "onclick": "OpenDoc()" },
                { "value": "Close", "onclick": "CloseDoc()" }
            ]
        }
    }
}
					</code>
				</pre>

				</section>


				<section>
					<h2>Oublions jQuery</h2>
					<pre>
					<code class='javascript'>
//Avant
const monElement = $('[data-my-selector]');

//Après
const monElement = document.querySelector('[data-my-selector]');
					</code>
				</pre>

				</section>
			</section>
			<section data-state="theme-color-blue-yellow">
				<section data-background=''>
					<h1>Les outils</h1>
				</section>
				<section data-background='https://nodejs.org/static/images/logos/nodejs-green.png'>
				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Node.js</h2>
					<ul>
						<li>JS côté serveur</li>
						<li>Apporte plein d'outils sous forme de modules</li>
						<li><a href='npmjs.com'>npm</a> (node package module)</li>
					</ul>
				</section>
				<section >
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Node.js</h2>
					<ul>
						<li>package.json</li>
						<li>node_modules</li>
						<li><code>npm install -g ma-dependance-globale</code></li>
						<li><code>npm install -g rimraf</code></li>
						<li><code>npm install --save ma-dependance</code></li>
					</ul>
				</section>
				<section data-background='http://www.kolhamevaser.com/wp-content/uploads/2015/05/Schechter.Bavel_.TowerofBavel.jpg'>
					<h1>Babel</h1>
				</section>
				<section data-background='http://jlongster.com/s/upload/webpack-hot1.png'>
			    		<h1 style='background-color:rgba(1,1,1, 0.5);'><a href='https://webpack.github.io/'>Webpack</a></h1>
				</section>

				<section data-background=''>
					<h1>Debug</h1>
				</section>
			</section>
			<section data-state="theme-color-blue-yellow">
				<section data-background='https://media.giphy.com/media/RHUGfUYnjNuMw/giphy.gif'>
					<h1>Prototypes / Constructor</h1>
				</section>
				<section>
					<h2>Classes ?</h2>
					<ul>
						<li>Avant ES6 pas de classe</li>
						<li>JS est un langage prototypale</li>
						<li>En JS tout est un objet</li>
						<li>Une propriété est identifiée par une paire nom / valeur</li>
						<li>Une propriété peut être une fonction</li>
					</ul>
				</section>
				<section>
					<h2>Constructeur</h2>
					<ul>
					    <li>Fonctions servant à initialiser un nouvel objet. Le nom du constructeur est un peu comme « le nom de la classe »…</li>
					    <li>Toute fonction peut servir de constructeur : il suffit de l’appeler avec l’opérateur new.</li>
					    <li>Elle dispose alors d’une variable implicite this, qui représente la nouvelle « instance ».</li>
					    <li>L’objet créé référence son constructeur : constructor.</li>
					</ul>
				</section>
				<section>
					<h2>Constructeur</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
}

var joeLopezPerson = new Person('Joe', 'Lopez');
var davidLopezz = new Person('David', 'lopez');
joeLopezPerson.first // => 'Joe'
davidLopezz.first   // => 'David'

// Si on jouait aux cons ?!
function LopezPerson(first, last) {
  this.first = first;
  this.last = last;
  return { first: 'Anne', last: 'Pas Lopez' };
}
var oops = new LopezPerson('Henry', 'Lopez');
oops.first // => Anne
						</code>
					</pre>
				</section>

				<section>
					<h2>Prototypes</h2>
					<ul>
					    <li>Tout constructeur a un prototype : un objet qui définit les propriétés (et donc méthodes) partagées par tous les objets que produit ce constructeur.</li>
					    <li>Le prototype est « vivant » : si on le triture après l’appel au constructeur, ça marche quand même !</li>
					    <li>Techniquement, y’a plein d’autres trucs dans un prototype (réf. au constructeur, gestion de propriétés…).</li>
						<li>On verra, plutôt vous verrez...</li>
					</ul>
				</section>
				<section>
					<h2>Prototype</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
}

// On augmente l'existant…
Person.prototype.fullName = function fullName() {
  return this.first + ' ' + this.last;
}
Person.prototype.greet = function greet() {
  alert('Salut je m’appelle ' + this.first);
}

var john = new Person('John', 'Smith');
john.fullName() // => 'John Smith'
john.greet()    // 'Salut je m’appelle John'
						</code>
					</pre>
				</section>
				<section>
					<h2>Prototype (Don't)</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
  this.fullName = function fullName() {
    return this.first + ' ' + this.last;
  }
  this.greet = function greet() {
    alert('Salut je m’appelle ' + this.first);
  }
}
var john = new Person('John', 'Smith');
john.fullName() // => 'John Smith'
john.greet()    // 'Salut je m’appelle John'
						</code>
					</pre>
					<blockquote>Mauvaise pratique: on copie la fonction dans chaque constructeur</blockquote>
				</section>
				<section>
					<h2>Les classes ES6</h2>
					<pre>
						<code class='javascript'>
class TodoItem extends Component {
  constructor(props, context) {
    super(props, context);
    this.state = {
      editing: false
    };
  }

  handleDoubleClick() {
    this.setState({ editing: true });
  }
  …
}
						</code>
					</pre>
					<blockquote class='fragment'>Attention il s'agit de sucre syntaxique pas d'une classe comme en Java ou .NET. Le JS reste un langage prototypale.</blockquote>
				</section>
				<section>
					<h2>La chaîne d'appel d'une méthode</h2>
					<code>obj.prop</code> ou <code>obj['prop']</code> (c'est équivalent)
					<ol>
						<li class='fragment'>On part de l’objet indexé (obj)</li>
						<li class='fragment'>Si on trouve prop dans ses own properties, on s’arrête là</li>
						<li class='fragment'>Sinon, on passe sur le prototype du niveau supérieur : celui du constructeur de l’objet en cours*</li>
						<li class='fragment'>On reprend à l’étape 2, sauf si on était déjà sur Object.prototype, auquel cas le lookup est fini, et échoue (undefined).</li>
					</ol>
					<footer>*conceptuellement, <code>constructor.prototype</code> ou <code>__proto__</code></footer>
				</section>
				<section data-background=''>
					<h2>La preuve en live...</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
}
Person.prototype.fullName = function fullName() {
  return this.first + ' ' + this.last;
};
const davidLopez = new Person('David', 'Lopez');

davidLopez.first      // => 'David',         own property
davidLopez.fullName() // => 'David Lopez', Person.prototype
davidLopez.toString() // => '[object Object]', Object.prototype

Person.prototype.toString = function personToString() {
  return '#Person ' + this.fullName();
};

davidLopez.toString() // => "#Person David Lopez"
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section data-background=''><h1>Closure</h1></section>
				<section >
					<h2>Closure simple</h2>

				</section>
				<section>
					<h2>Les modules sont une utilisation des closures</h2>
					<pre><code class="javascript">
function yourModule(require, module, exports) {

  let widgets = {};
  let util = require('util');
  let Widget = require('widgets/base');

  function CoolWidget(elt) { … }
  util.inherits(CoolWidget, Widget);
  // …

  module.exports = Widget;
}
					</code></pre>
					<blockquote>Dans node on ne voit pas la fonction enrobante...</blockquote>
				</section>
				<section data-background='http://995642590.r.lightningbase-cdn.com/wp-content/uploads/2013/05/HR-Double-Bind-article-by-John-Sumser-on-HR-Examiner-425x282px.jpg'>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Le binding</h2>

				</section>
				<section data-background='http://995642590.r.lightningbase-cdn.com/wp-content/uploads/2013/05/HR-Double-Bind-article-by-John-Sumser-on-HR-Examiner-425x282px.jpg'>
					<h2>Le problème</h2>
					<pre>
						<code class='javascript'>
var name = 'Mr X';
let obj = {
  name: 'Joe Lopez',
  greet: function greet(whom) {
	console.log(this)
    console.log(this.name + ' salue ' + whom);
  },
  greetAll: function greetAll(first, second, last) {
	console.log(this)
    [first, second, last].forEach(this.greet);
  }
};
obj.greet("les lopezs de France");
// => 'Joe Lopez salut les lopezs de France !'
let fx = obj.greet;
fx("l’atelier") // => '"Mr X salue l’atelier"'
obj.greetAll('David', 'Joe', 'Guénolé'); // => 'Mr X salue David, Mr X salue Joe, Mr X salue undefined'
						</code>
					</pre>
				</section>
				<section data-background='http://995642590.r.lightningbase-cdn.com/wp-content/uploads/2013/05/HR-Double-Bind-article-by-John-Sumser-on-HR-Examiner-425x282px.jpg'>
					<h2>Comment faire ? La closure?</h2>
					<pre>
						<code class='javascript'>
const obj = {
  // …
  greetAll: function greetAll(first, second, last) {
    var that = this;
    [first, second, last].forEach(function(name) {
      that.greet(name);
    });
  }
}
						</code>
					</pre>
				</section>
				<section data-background=''>
					<h2>Comment faire ? ES6 style?</h2>
					<pre>
						<code class='javascript'>
const obj = {
  // …
  greetAll(first, second, last) {
    [first, second, last].forEach(name => this.greet(name));
	//Ultra fat
  }
}
						</code>
					</pre>
				</section>
				<section>
					<h2>call et apply</h2>
					<pre>
						<code class='javascript'>


//let fx = obj.greet;
fx.call(obj, 'les singes') // Joe Lopez salue les singes


let xy = { 0: 'Zero', 1: 'One', length: 2 };
Array.prototype.join.call(xy, '-') // 'Zero-One'


fx.apply(obj, ['']) // => 'Joe salue l’atelier'
Array.prototype.push.apply(xy, ['Two', 'Three', 'Four']) // => 5
xy // => { 0: 'Zero', 1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', length: 5 }
</code>
</pre>

				</section>
			</section>
			<section >
				<section data-background='http://104.236.204.173/wp-content/uploads/2015/05/async.jpg'>
					<h1 style='background-color:rgba(1,1,1, 0.5);'>JS et asynchronisme</h1>
				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Callback</h2>
					<pre>
						<code>
function delayedAlert() {
  window.setTimeout(slowAlert, 2000);
}

function slowAlert() {
  alert("That was really slow!");
}
					</code></pre>
				</section>
				<section>
					<h2>Les promesses</h2>
					<p>
						Une promesse a un état (pending, fullfilled, rejected).<br>
						Elle est asynchrone, et se termine soit par un succès soit par une erreur et renvoie une nouvelle promesse.
					</p>
					<code class='javascript'>promise.then(successCb,errorCb).then(otherSuccess, otherCb).catch(errorHandlingFn)</code>

				</section>
				<section>
					<h2>Les promesses</h2>
					<pre><code class='javascript'>
const myPromise = new Promise((resolve, reject) => {
	ajaxCall({success: resolve, error: reject});
})

Promise.resolve([1,2,3,4]);

Promise.reject('ma super erreur')

					</code></pre>

				</section>
				<section>
					<H2 style='background-color:rgba(1,1,1, 0.5);'>Les promesses</H2>
					<pre class='javascript'><code>
fetch('/users.json')
  .then(function(response) {
    return response.json()
  }).then(function(json) {
    console.log('parsed json', json)
  }).catch(function(ex) {
    console.log('parsing failed', ex)
  })					</code></pre>
				</section>
			</section>
			<section >
				<section data-background=''>
					<h1>ES6 / 2015</h1>
				</section>
				<section>
					<h2>Les modules de node</h2>
					<pre>
						<code class='javascript'>
//Dans un fichier
module.exports = monObjetAExporter;

//Utilisation
require('./mon_module_locale');
//Utilisation d'un module npm
require('mon_module');
</code>


					</pre>
				</section>
				<section>
					<h2>Les modules de Papa</h2>
					<pre>
						<code class='javascript'>
import * as types from '../constants/ActionTypes';

export function addTodo(text) {
  return { type: types.ADD_TODO, text };
}
import React, { PropTypes, Component } from 'react';
import classnames from 'classnames';
import { SHOW_ALL, SHOW_COMPLETED, SHOW_ACTIVE } from '../constants/TodoFilters';
import 'http://material.js'
…
export default Footer;
export const ADD_TODO = 'ADD_TODO';
export const DELETE_TODO = 'DELETE_TODO';
export const EDIT_TODO = 'EDIT_TODO';

</code>


					</pre>
				</section>

				<section>
					<h2>Destruct</h2>
					<pre>
						<code class='javascript'>
const { activeCount } = this.props;
…
const { filter: selectedFilter, onShow } = this.props;
const [, filters] = output.props.children;
…
const [,, clear] = output.props.children;
var { op: a, lhs: { op: b }, rhs: c } = getASTNode();
Détails
</code>


					</pre>
				</section>
				<section>
					<h2>Les strings interpolation et multi lignes</h2>
					<pre>
						<code class='javascript'>
const person = { first: 'Thomas', last: 'Anderson', age: 25, nickname: 'Neo' };

// Interpolation de JS quelconque
console.log(`${person.first} aka ${person.nickname}`)
// => 'Thomas aka Neo'

// Multi-ligne !
const markup = `<li>
${person.first} ${person.last}, age ${person.age}
</li>`;

					</code>


					</pre>
				</section>
				<section>
					<h2>Valeur par défaut dans une fonction</h2>
					<pre>
						<code class='javascript'>
function add(source, numToAdd = 1){
	return source + numToAdd;
}
						</code>


					</pre>
				</section>
				<section>
					<h2>Les objets</h2>
					<pre>
						<code class='javascript'>
function editTodo(id, text) {
  return { type: types.EDIT_TODO, id, text };
  //On créé un objet avec pour clef le nom de la variable.
}
const FILTERS = {
  [maVar1]: 'All',
  [maVar2]: 'Active',
  [maVar3]: 'Completed'
};
						</code>


					</pre>
				</section>
			</section>
			<section >
				<section data-background=''>
					<h1 style='background-color:rgba(1,1,1, 0.5);'>LODASH / UNDERSCORE</h1>

				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>on ne réinvente pas la roue</h2>
				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Les trucs utiles</h2>
					<ul>
						<li>Est ce que ma variable est un nombre / function / tableau <code>lodash/lang</code></li>
						<li>Filtrer, trier, reduce.... <code>lodash/{collection/object/array}</code></li>
						<li>Plein de fonctions prêtes à l'emploi <code>lodash/function</code></li>
					</ul>
				</section>
			</section>
			<section >
				<section data-background='http://cdn.londonandpartners.com/visit/london-organisations/big-ben/63602-640x360-bigben_tilt_640.jpg'>
					<h1 style='background-color:rgba(1,1,1, 0.5);'><a href='http://momentjs.com'>MOMENT</a></h1>
				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>on ne réinvente pas la roue</h2>
		        	<iframe webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen="" sandbox="allow-forms allow-scripts allow-popups allow-same-origin allow-pointer-lock" data-src="http://momentjs.com/" src="http://momentjs.com/" height='50%'  width='80%'></iframe>
				</section>
				<section>
					<h2 style='background-color:rgba(1,1,1, 0.5);'>Les trucs utiles</h2>
					<ul>
						<li>formatter des dates <code>moment().format('L')</code></li>
						<li>Manipuler des dates <code>moment(maDate).add('days', 1)</code></li>
						<li>Timezone...</li>
					</ul>
					<blockquote>Si tu manipules des dates tu utilises momentjs</blockquote>
				</section>
			</section>
			<section >
				<section>
					<h1 style='background-color:rgba(1,1,1, 0.5);'><a href='https://github.com/get-focus/formation-js/tree/master/exercices'>Exercices</a></h1>
				</section>
			</section>
		</div>
	</div>
	<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
</body>
</html>
